const std = @import("std");
const ast = @import("ast.zig");
const Ast = ast.Ast;
const Declaration = ast.Declaration;
const ClassDecl = ast.ClassDecl;
const EnumDecl = ast.EnumDecl;
const FunctionDecl = ast.FunctionDecl;
const TypeExpr = ast.TypeExpr;
const Property = ast.Property;
const EnumValue = ast.EnumValue;
const Parameter = ast.Parameter;
const PrimitiveType = ast.PrimitiveType;

/// Python code generator
pub const PythonGenerator = struct {
    allocator: std.mem.Allocator,
    buffer: *std.ArrayList(u8),
    indent_level: usize,

    pub fn init(allocator: std.mem.Allocator, buffer: *std.ArrayList(u8)) PythonGenerator {
        return PythonGenerator{
            .allocator = allocator,
            .buffer = buffer,
            .indent_level = 0,
        };
    }

    /// Generate Python code from AST
    pub fn generate(self: *PythonGenerator, tree: *const Ast) !void {
        // Write header with imports
        try self.writeHeader();

        // Generate code for each declaration
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| try self.generateClass(&class),
                .enum_decl => |enm| try self.generateEnum(&enm),
                .function_decl => |func| try self.generateFunction(&func),
                else => {}, // Skip client, test, generator declarations
            }
            try self.writeLine("");
        }
    }

    fn writeHeader(self: *PythonGenerator) !void {
        try self.writeLine("# Generated by minibaml");
        try self.writeLine("# DO NOT EDIT - This file is auto-generated");
        try self.writeLine("");
        try self.writeLine("from typing import Optional, Union, List, Dict, Any");
        try self.writeLine("from pydantic import BaseModel, Field");
        try self.writeLine("from enum import Enum");
        try self.writeLine("");
    }

    fn generateClass(self: *PythonGenerator, class: *const ClassDecl) !void {
        // Write docstring if present
        if (class.docstring) |doc| {
            try self.write("\"\"\"");
            try self.write(doc);
            try self.writeLine("\"\"\"");
        }

        // Write class definition
        try self.write("class ");
        try self.write(class.name);
        try self.writeLine("(BaseModel):");

        self.indent_level += 1;

        // Handle empty class
        if (class.properties.items.len == 0) {
            try self.writeLine("pass");
        } else {
            // Generate properties
            for (class.properties.items) |prop| {
                try self.generateProperty(&prop);
            }
        }

        self.indent_level -= 1;
    }

    fn generateProperty(self: *PythonGenerator, prop: *const Property) !void {
        // Write docstring if present
        if (prop.docstring) |doc| {
            try self.writeLine("\"\"\"");
            try self.writeIndent();
            try self.write(doc);
            try self.write("\n");
            try self.writeLine("\"\"\"");
        }

        // Write property name with indentation
        try self.writeIndent();
        try self.write(prop.name);
        try self.write(": ");

        // Write type annotation
        try self.writeTypeAnnotation(prop.type_expr);

        // Check for @alias attribute and add Field with alias
        var has_alias = false;
        var alias_name: ?[]const u8 = null;
        for (prop.attributes.items) |attr| {
            if (std.mem.eql(u8, attr.name, "alias") and attr.args.items.len > 0) {
                if (attr.args.items[0] == .string) {
                    has_alias = true;
                    alias_name = attr.args.items[0].string;
                    break;
                }
            }
        }

        if (has_alias and alias_name != null) {
            try self.write(" = Field(alias=\"");
            try self.write(alias_name.?);
            try self.write("\")");
        }

        try self.write("\n");
    }

    fn generateEnum(self: *PythonGenerator, enm: *const EnumDecl) !void {
        // Write docstring if present
        if (enm.docstring) |doc| {
            try self.write("\"\"\"");
            try self.write(doc);
            try self.writeLine("\"\"\"");
        }

        // Write enum definition
        try self.write("class ");
        try self.write(enm.name);
        try self.writeLine("(str, Enum):");

        self.indent_level += 1;

        // Handle empty enum
        if (enm.values.items.len == 0) {
            try self.writeLine("pass");
        } else {
            // Generate enum values
            for (enm.values.items) |val| {
                try self.generateEnumValue(&val);
            }
        }

        self.indent_level -= 1;
    }

    fn generateEnumValue(self: *PythonGenerator, val: *const EnumValue) !void {
        // Write docstring if present
        if (val.docstring) |doc| {
            try self.writeLine("\"\"\"");
            try self.writeIndent();
            try self.write(doc);
            try self.write("\n");
            try self.writeLine("\"\"\"");
        }

        try self.writeIndent();
        try self.write(val.name);
        try self.write(" = \"");
        try self.write(val.name);
        try self.write("\"\n");
    }

    fn generateFunction(self: *PythonGenerator, func: *const FunctionDecl) !void {
        // Write docstring if present
        if (func.docstring) |doc| {
            try self.write("\"\"\"");
            try self.write(doc);
            try self.writeLine("\"\"\"");
        }

        // Write function signature
        try self.write("def ");
        try self.write(func.name);
        try self.write("(");

        // Write parameters
        for (func.parameters.items, 0..) |param, i| {
            if (i > 0) try self.write(", ");
            try self.write(param.name);
            try self.write(": ");
            try self.writeTypeAnnotation(param.type_expr);
        }

        try self.write(") -> ");
        try self.writeTypeAnnotation(func.return_type);
        try self.writeLine(":");

        self.indent_level += 1;

        // Write function body (stub)
        if (func.prompt) |prompt| {
            try self.writeLine("\"\"\"");
            var lines = std.mem.splitSequence(u8, prompt, "\n");
            while (lines.next()) |line| {
                try self.writeIndent();
                try self.buffer.appendSlice(self.allocator, line);
                try self.buffer.append(self.allocator, '\n');
            }
            try self.writeLine("\"\"\"");
        }

        try self.writeLine("raise NotImplementedError(\"This is a stub for LLM function\")");

        self.indent_level -= 1;
    }

    fn writeTypeAnnotation(self: *PythonGenerator, type_expr: *const TypeExpr) !void {
        switch (type_expr.*) {
            .primitive => |prim| {
                const python_type = mapPrimitiveType(prim);
                try self.write(python_type);
            },
            .named => |name| {
                try self.write(name);
            },
            .array => |inner| {
                try self.write("List[");
                try self.writeTypeAnnotation(inner);
                try self.write("]");
            },
            .optional => |inner| {
                try self.write("Optional[");
                try self.writeTypeAnnotation(inner);
                try self.write("]");
            },
            .union_type => |union_ty| {
                try self.write("Union[");
                for (union_ty.types.items, 0..) |ty, i| {
                    if (i > 0) try self.write(", ");
                    try self.writeTypeAnnotation(ty);
                }
                try self.write("]");
            },
            .map => |map| {
                try self.write("Dict[");
                try self.writeTypeAnnotation(map.key_type);
                try self.write(", ");
                try self.writeTypeAnnotation(map.value_type);
                try self.write("]");
            },
            .literal => |lit| {
                switch (lit) {
                    .string => |s| {
                        try self.write("\"");
                        try self.write(s);
                        try self.write("\"");
                    },
                    .int => |i| {
                        var buf: [32]u8 = undefined;
                        const str = try std.fmt.bufPrint(&buf, "{d}", .{i});
                        try self.write(str);
                    },
                    .float => |f| {
                        var buf: [32]u8 = undefined;
                        const str = try std.fmt.bufPrint(&buf, "{d}", .{f});
                        try self.write(str);
                    },
                    .bool => |b| {
                        try self.write(if (b) "True" else "False");
                    },
                    .null_value => {
                        try self.write("None");
                    },
                }
            },
        }
    }

    fn mapPrimitiveType(prim: PrimitiveType) []const u8 {
        return switch (prim) {
            .string => "str",
            .int => "int",
            .float => "float",
            .bool => "bool",
            .null_type => "None",
            .image => "Any",  // Image type as Any for now
            .audio => "Any",  // Audio type as Any for now
            .video => "Any",  // Video type as Any for now
            .pdf => "Any",    // PDF type as Any for now
        };
    }

    fn write(self: *PythonGenerator, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, text);
    }

    fn writeLine(self: *PythonGenerator, text: []const u8) !void {
        try self.writeIndent();
        try self.buffer.appendSlice(self.allocator, text);
        try self.buffer.append(self.allocator, '\n');
    }

    fn writeIndent(self: *PythonGenerator) !void {
        var i: usize = 0;
        while (i < self.indent_level) : (i += 1) {
            try self.buffer.appendSlice(self.allocator, "    ");
        }
    }
};

// Tests
test "PythonGenerator: simple class" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add a property: name string
    const name_type = try allocator.create(TypeExpr);
    name_type.* = .{ .primitive = .string };

    var attributes = std.ArrayList(ast.Attribute).init(allocator);
    defer attributes.deinit(allocator);

    const name_prop = Property{
        .name = "name",
        .type_expr = name_type,
        .attributes = attributes,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, name_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "class Person(BaseModel):") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "name: str") != null);
}

test "PythonGenerator: simple enum" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var enum_decl = EnumDecl.init(allocator, "Status", .{ .line = 1, .column = 1 });
    defer enum_decl.deinit(allocator);

    const active = EnumValue{
        .name = "Active",
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try enum_decl.values.append(allocator, active);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "class Status(str, Enum):") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "Active = \"Active\"") != null);
}

test "PythonGenerator: optional and array types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: age int?
    const int_type = try allocator.create(TypeExpr);
    int_type.* = .{ .primitive = .int };

    const age_type = try allocator.create(TypeExpr);
    age_type.* = .{ .optional = int_type };

    const age_prop = Property{
        .name = "age",
        .type_expr = age_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, age_prop);

    // Add property: tags string[]
    const str_type = try allocator.create(TypeExpr);
    str_type.* = .{ .primitive = .string };

    const tags_type = try allocator.create(TypeExpr);
    tags_type.* = .{ .array = str_type };

    const tags_prop = Property{
        .name = "tags",
        .type_expr = tags_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 3, .column = 3 },
    };
    try class_decl.properties.append(allocator, tags_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "age: Optional[int]") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "tags: List[str]") != null);
}

test "PythonGenerator: map types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: metadata map<string, string>
    const key_type = try allocator.create(TypeExpr);
    key_type.* = .{ .primitive = .string };

    const value_type = try allocator.create(TypeExpr);
    value_type.* = .{ .primitive = .string };

    const map_type = try allocator.create(TypeExpr);
    map_type.* = .{ .map = .{ .key_type = key_type, .value_type = value_type } };

    const meta_prop = Property{
        .name = "metadata",
        .type_expr = map_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, meta_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "metadata: Dict[str, str]") != null);
}

test "PythonGenerator: union types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Extract", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Return type: Person | null
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const null_type = try allocator.create(TypeExpr);
    null_type.* = .{ .primitive = .null_type };

    var types = std.ArrayList(*TypeExpr).init(allocator);
    try types.append(allocator, person_type);
    try types.append(allocator, null_type);

    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .union_type = .{ .types = types } };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "Union[Person, None]") != null);
}

test "PythonGenerator: function with parameters" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Greet", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Parameter: p: Person
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const param = Parameter{
        .name = "p",
        .type_expr = person_type,
        .location = .{ .line = 1, .column = 15 },
    };
    try func_decl.parameters.append(allocator, param);

    // Return type: string
    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .primitive = .string };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "def Greet(p: Person) -> str:") != null);
}

test "PythonGenerator: property with alias" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: email string @alias("email_address")
    const email_type = try allocator.create(TypeExpr);
    email_type.* = .{ .primitive = .string };

    var attr = ast.Attribute{
        .name = "alias",
        .is_class_level = false,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 2, .column = 10 },
    };
    try attr.args.append(allocator, .{ .string = "email_address" });

    var attrs = std.ArrayList(ast.Attribute).init(allocator);
    try attrs.append(allocator, attr);

    const email_prop = Property{
        .name = "email",
        .type_expr = email_type,
        .attributes = attrs,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, email_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "email: str = Field(alias=\"email_address\")") != null);
}
